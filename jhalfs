#!/bin/sh

version="
jhalfs development

Written by Jeremy Huntwork.
Maintained by Manuel Canales Esparcia.

This program is published under the \
Gnu General Public License, Version 2.
"

usage="\
Usage: $0 [OPTION]

Options:
  -h, --help                    print this help, then exit
  -V, --version                 print version number, then exit
  -L, --LFS-version=VER         use VER version of the LFS book
  -d  --directory=DIR           use DIR directory for building LFS; all files
                                jhalfs produces will be in the directory
                                DIR/jhalfs
  -D, --download-client=CLIENT  use CLIENT as the program for retrieving
                                packages
"

help="\
Try '$0 --help' for more information."

exit_missing_arg="\
echo \"Option '\$1' requires an argument\" >&2
echo \"\$help\" >&2
exit 1"

no_dl_client="\
echo \"Could not find a way to download the LFS sources.\" >&2
echo \"Attempting to continue.\" >&2"

while test $# -gt 0 ; do
  case $1 in
    --version | -V )
      echo "$version"
      exit 0
      ;;

    --help | -h )
      echo "$usage"
      exit 0
      ;;

    --LFS-version | -L )
      test $# = 1 && eval "$exit_missing_arg"
      shift
      case $1 in
        dev* | SVN | trunk )
          LFSVRS=development
          ;;
        * )
          echo "$1 is an unsupported version at this time."
          exit 1
          ;;
      esac
      shift
      ;;

    --directory | -d )
      test $# = 1 && eval "$exit_missing_arg"
      shift
      BUILDDIR=$1
      shift
      ;;

    --download-client | -D )
      test $# = 1 && eval "$exit_missing_arg"
      shift
      DL=$1
      shift
      ;;

    * )
      echo "$usage"
      exit 1
      ;;
  esac
done

# Test to make sure we're running the build as root

if [ "$UID" != "0" ] ; then
  echo "You must be logged in as root to successfully build LFS."
  exit 1
fi

# Find the download client to use, if not already specified.

if [ -z $DL ] ; then
  if [ `type -p wget` ] ; then
    DL=wget
  elif [ `type -p curl` ] ; then
    DL=curl
  else
    eval "$no_dl_client"
  fi
fi

SVN="svn://svn.linuxfromscratch.org"
HTTP=http://ftp.lfs-matrix.net/pub/lfs/lfs-packages/conglomeration
if [ -z $BUILDDIR ] ; then BUILDDIR=/mnt/lfs ; fi
JHALFSDIR=$BUILDDIR/jhalfs
LOG=build.log
MKFILE=$JHALFSDIR/Makefile
XSL=dump-commands.xsl

get_book() {
  # Check for Subversion instead of just letting the script hit 'svn' and fail.
  test `type -p svn` || eval "echo \"This feature requires Subversion.\"
  exit 1"
  cd $JHALFSDIR

  # Test to make sure the LFS version is set
  if [ -z $LFSVRS ] ; then LFSVRS=development ; fi
  echo -n "Downloading the LFS Book, version $LFSVRS... "

  # Grab the LFS book fresh if it's missing, otherwise, update it from the
  # repo. If we've already extracted the commands, move on to getting the
  # sources.
  if [ -d lfs-$LFSVRS ] ; then
    cd lfs-$LFSVRS
    if svn up | grep -q At && test -d $JHALFSDIR/commands && \
    test -f $JHALFSDIR/packages && test -f $JHALFSDIR/patches ; then
      echo -ne "done\n"
      get_sources
    else
      echo -ne "done\n"
      extract_commands
    fi
  else
    if [ $LFSVRS = development ] ; then
      svn co $SVN/LFS/trunk/BOOK lfs-$LFSVRS >>$JHALFSDIR/$LOG 2>&1
    else
      svn co $SVN/LFS/branches/$LFSVRS/BOOK lfs-$LFSVRS >>$JHALFSDIR/$LOG 2>&1
    fi
    echo -ne "done\n"
    extract_commands
  fi
}

extract_commands() {
  # Check for libxslt instead of just letting the script hit 'xsltproc' and fail.
  test `type -p xsltproc` || eval "echo \"This feature requires libxslt.\"
  exit 1"
  cd $JHALFSDIR

  # Start clean
  if [ -d commands ] ; then rm -rf commands ; fi && mkdir commands
  echo -n "Extracting commands... "

  # Dump the commands in text form from the LFS book.
  xsltproc --nonet --xinclude -o ./commands/ $XSL \
  lfs-$LFSVRS/index.xml >>$JHALFSDIR/$LOG 2>&1

  # Grab the patches and package names.
  cd $JHALFSDIR
  for i in patches packages ; do rm -f $i ; done
  grep "\-version" lfs-$LFSVRS/general.ent | sed -e 's@<!ENTITY @@' -e 's@">@"@' \
  -e '/generic/d' >> packages
  grep "ENTITY" lfs-$LFSVRS/patches.ent | sed -e 's/.* "//' -e 's/">//' >> patches

  # Done. Moving on...
  echo -ne "done\n"
  get_sources
}

download() {
  cd $BUILDDIR/sources

  # Hackish fix for the bash-doc package that doesn't conform
  # to norms in the URL scheme.
  DIR=`echo $1 | sed 's@-doc@@'`

  # Find the md5 sum for this package.
  if [ $2 != MD5SUMS ] ; then MD5=`grep "  $2" MD5SUMS` ; fi

  if [ ! -f $2 ] ; then
    case $DL in
      wget )
        wget $HTTP/$DIR/$2
        ;;
      curl )
        `curl -# $HTTP/$DIR/$2 -o $2`
        ;;
      * )
        echo "$DL not supported at this time."
        ;;
    esac
  elif ! echo "$MD5" | md5sum -c - >/dev/null 2>/dev/null ; then
    case $DL in
      wget )
        wget -c $HTTP/$DIR/$2
        ;;
      curl )
        `curl -# -C - $HTTP/$DIR/$2 -o $2`
        ;;
      * )
        echo "$DL not supported at this time."
        ;;
    esac
  fi
  if [ $2 != MD5SUMS ] && ! echo "$MD5" | md5sum -c - ; then
    exit 1
  fi
}

get_sources() {

  # This variable is necessary to make sure the `cat $JHALFSDIR/packages`
  # separates each iteration by lines.  It is necessary to have the second
  # ' on the next line.
  IFS='
'

  if [ ! -d $BUILDDIR/sources ] ; then mkdir $BUILDDIR/sources ; fi
  cd $BUILDDIR/sources
  if [ -f MD5SUMS ] ; then rm MD5SUMS ; fi

  download "" MD5SUMS

  # Iterate through each package and grab it, along with any patches it needs.
  for i in `cat $JHALFSDIR/packages` ; do
    PKG=`echo $i | sed 's/-version.*//'`

    # Someone used some silly entities right next to the valid package entities.
    if [ "$PKG" = "expect-lib" -o "$PKG" = "linux-dl" ] ; then continue ; fi

    VRS=`echo $i | sed -e 's/.* //' -e 's/"//g'`
    if [ "$PKG" = "tcl" ] ; then
      FILE="$PKG$VRS-src.tar.bz2"
    else
      FILE="$PKG-$VRS.tar.bz2"
    fi
    download $PKG $FILE
    for patch in `grep "$PKG-&$PKG" $JHALFSDIR/patches` ; do
      PATCH=`echo $patch | sed 's@&'$PKG'-version;@'$VRS'@'`
      download $PKG $PATCH
    done
  done
}

build_Makefile() {
  echo -n "Creating Makefile... "
  cd $JHALFSDIR/commands

  # Start with a clean Makefile.tmp file
  >$MKFILE.tmp

  for file in chapter0{4,5}/* ; do
  # Keep the script file name
  i=`basename $file`

  # First append each name of the script files to a list (this will become
  # the names of the targets in the Makefile
  list="$list $i"

  # Grab the name of the target (minus the -pass1 or -pass2 in the case of gcc
  # and binutils in chapter 5)
  name=`echo $i | sed -e 's@[0-9]\{3\}-@@' -e 's@-pass[0-9]\{1\}@@'`

  # Drop in the name of the target on a new line.
  echo -e "\n$i:" >> $MKFILE.tmp

  # Find the version of the command files, if it corresponds with the building of
  # a specific package
  vrs=`grep "^$name-version" $JHALFSDIR/packages | sed -e 's/.* //' -e 's/"//g'`

  # If $vrs isn't empty, we've got a package...
  if [ "$vrs" != "" ] ; then
    if [ "$name" = "tcl" ] ; then
      FILE="$name$vrs-src.tar.bz2"
    else
      FILE="$name-$vrs.tar.bz2"
    fi

    # Insert instructions for unpacking the package and changing directories
    echo -e "\t\$(call unpack,$FILE)" >> $MKFILE.tmp
    echo -e "\tROOT=\`head -n1 /tmp/unpacked | sed 's@/.*@@'\` && \\" >> $MKFILE.tmp
    echo -e "\tcd \$(SRC)/\$\$ROOT && \\" >> $MKFILE.tmp
  fi

#   # Drop in the actual commands that were parsed from the book
#   # These seds add an extra $ to each variable so make doesn't break,
#   # add tabs to the beginning of each line, and add ' && \' to the end
#   # of each line except for those that end in '\'.
#   cat $i | sed -e 's:\$:&&:g' -e 's:^:\t:' -e 's:[^\\]$:& \&\& \\:' >> $MKFILE.tmp
#   # This sed removes the ' && \' from the last command of each target
#   sed -i '$s: \&\& \\::' $MKFILE.tmp

  # Run the script
  echo -e "\tsu - lfs -c \"/bin/bash $file\"" >> $MKFILE.tmp

  # Include a touch of the target name so make can check if it's already been made.
  echo -e "\ttouch \$@" >> $MKFILE.tmp
  done
  # These seds turn the variables '$$LFS' into '$(LFS)' so make will understand,
  # and remove the ' && \'s from the end of each line of a cat command.
  sed -i -e 's|\$\$LFS|\$(LFS)|' -e '/^\tcat/,/^\tEOF/s/ \&\& \\//' $MKFILE.tmp

  # Stick a variable and some defines at the top of the real makefile
  echo "export SRC := /sources" > $MKFILE
  echo "export LFS := $BUILDDIR" >> $MKFILE
  echo "define unpack" >> $MKFILE
  echo -e "\t@cd \$(SRC) ; tar -xvf \$(1) > /tmp/unpacked" >> $MKFILE
  echo -e "endef\n" >> $MKFILE

  # Drop in the list as the main target 'all:' with each sub-target as a dependency.
  echo "all: $list" >> $MKFILE

  # Bring over the items from the Makefile.tmp
  cat $MKFILE.tmp >> $MKFILE
  rm $MKFILE.tmp
  echo -ne "done\n"
}


if [ ! -d $JHALFSDIR ] ; then
  mkdir -p $JHALFSDIR
fi

>$JHALFSDIR/$LOG

if [ "$PWD" != "$JHALFSDIR" ] ; then
  cp $0 $XSL $JHALFSDIR/
fi

get_book
build_Makefile
